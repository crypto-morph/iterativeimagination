#!/usr/bin/env python3
"""
iterativectl - Management tool for Iterative Imagination projects

Commands:
  comfyui start|stop|restart|status  - Manage ComfyUI server
  project create <name>              - Create a new project from defaults
  rules check|suggest                - Lint and AI-suggest acceptance_criteria tags in rules.yaml
  run                               - Run iterative_imagination.py (start/reset/resume)
  viewer start|stop|restart|status   - Manage the local viewer web app
"""

import argparse
import os
import sys
import shutil
import subprocess
import socket
import time
import signal
import yaml
import json
import urllib.request
import urllib.error
from pathlib import Path


# Get the script directory (ComfyScripts)
SCRIPT_DIR = Path(__file__).parent.resolve()
DEFAULTS_DIR = SCRIPT_DIR / "defaults"
PROJECTS_DIR = SCRIPT_DIR / "projects"

# Find ComfyUI directory - check environment variable first, then common locations
def find_comfyui_dir():
    """Find ComfyUI installation directory."""
    # Check environment variable
    env_path = os.environ.get("COMFYUI_DIR")
    if env_path:
        path = Path(env_path).expanduser().resolve()
        if (path / "main.py").exists():
            return path
    
    # Check if we're inside ComfyUI (legacy location)
    parent = SCRIPT_DIR.parent
    if (parent / "main.py").exists():
        return parent
    
    # Check common locations
    common_paths = [
        Path.home() / "ComfyUI",
        Path("/opt/ComfyUI"),
        Path("/usr/local/ComfyUI"),
    ]
    
    for path in common_paths:
        if (path / "main.py").exists():
            return path
    
    # Default fallback
    return Path.home() / "ComfyUI"

COMFYUI_DIR = find_comfyui_dir()


def check_port_open(host="localhost", port=8188):
    """Check if a TCP port is open."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((host, port))
        sock.close()
        return result == 0
    except Exception:
        return False


def check_comfyui_running(host="localhost", port=8188):
    """Check if ComfyUI is running by testing the port."""
    return check_port_open(host=host, port=port)


def get_comfyui_pid():
    """Find ComfyUI process by checking for main.py."""
    try:
        result = subprocess.run(
            ["pgrep", "-f", "python.*main.py"],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            pids = result.stdout.strip().split('\n')
            # Filter to only processes in ComfyUI directory
            for pid in pids:
                if pid:
                    try:
                        # Check if process is actually ComfyUI
                        proc_path = Path(f"/proc/{pid}/cwd")
                        if proc_path.exists():
                            cwd = proc_path.resolve()
                            if str(COMFYUI_DIR) in str(cwd):
                                return int(pid)
                    except Exception:
                        continue
    except Exception:
        pass
    return None


def comfyui_status():
    """Check and display ComfyUI status."""
    is_running = check_comfyui_running()
    pid = get_comfyui_pid()
    
    if is_running and pid:
        print(f"✓ ComfyUI is running (PID: {pid}, Port: 8188)")
        return 0
    elif pid:
        print(f"⚠ ComfyUI process found (PID: {pid}) but port 8188 is not responding")
        return 1
    else:
        print("✗ ComfyUI is not running")
        return 1


def comfyui_start():
    """Start ComfyUI server."""
    if check_comfyui_running():
        print("✓ ComfyUI is already running")
        return 0
    
    print("Starting ComfyUI...")
    
    # Check if we're in a virtual environment or need to activate one
    venv_python = COMFYUI_DIR / "venv" / "bin" / "python"
    if venv_python.exists():
        python_cmd = str(venv_python)
    else:
        python_cmd = sys.executable
    
    # Start ComfyUI in background
    try:
        # Redirect output to log file
        log_file = COMFYUI_DIR / "comfyui.log"
        with open(log_file, 'w') as log:
            process = subprocess.Popen(
                [python_cmd, "main.py", "--listen", "127.0.0.1", "--port", "8188"],
                cwd=str(COMFYUI_DIR),
                stdout=log,
                stderr=subprocess.STDOUT,
                start_new_session=True
            )
        
        # Wait and check if it started (ComfyUI can take 10-30 seconds to fully start)
        print("  Waiting for ComfyUI to initialize...")
        max_wait = 30
        waited = 0
        while waited < max_wait:
            time.sleep(2)
            waited += 2
            if check_comfyui_running():
                print(f"✓ ComfyUI started successfully (PID: {process.pid})")
                print(f"  Access at: http://localhost:8188")
                print(f"  Logs: {log_file}")
                return 0
            # Show progress
            if waited % 6 == 0:
                print(f"  Still starting... ({waited}s)")
        
        # Final check
        if check_comfyui_running():
            print(f"✓ ComfyUI started successfully (PID: {process.pid})")
            print(f"  Access at: http://localhost:8188")
            print(f"  Logs: {log_file}")
            return 0
        else:
            print("✗ ComfyUI failed to start or is taking too long")
            print(f"  Check logs: {log_file}")
            # Show last few lines of log
            if log_file.exists():
                with open(log_file, 'r') as f:
                    lines = f.readlines()
                    if lines:
                        print("  Last log lines:")
                        for line in lines[-5:]:
                            print(f"    {line.rstrip()}")
            print("  Or run manually: cd ~/ComfyUI && python main.py --listen 127.0.0.1 --port 8188")
            # Don't kill the process - it might still be starting
            return 1
    except Exception as e:
        print(f"✗ Error starting ComfyUI: {e}")
        return 1


def comfyui_stop():
    """Stop ComfyUI server."""
    pid = get_comfyui_pid()
    
    if not pid:
        if check_comfyui_running():
            print("⚠ ComfyUI port is open but process not found")
            print("  You may need to stop it manually")
            return 1
        else:
            print("✓ ComfyUI is not running")
            return 0
    
    print(f"Stopping ComfyUI (PID: {pid})...")
    
    try:
        os.kill(pid, signal.SIGTERM)
        
        # Wait for process to stop
        for _ in range(10):
            time.sleep(0.5)
            if not check_comfyui_running():
                print("✓ ComfyUI stopped successfully")
                return 0
        
        # If still running, force kill
        if check_comfyui_running():
            print("⚠ Force killing ComfyUI...")
            os.kill(pid, signal.SIGKILL)
            time.sleep(1)
            if not check_comfyui_running():
                print("✓ ComfyUI stopped")
                return 0
        
        print("✗ Failed to stop ComfyUI")
        return 1
    except ProcessLookupError:
        print("✓ ComfyUI process not found (already stopped)")
        return 0
    except Exception as e:
        print(f"✗ Error stopping ComfyUI: {e}")
        return 1


def comfyui_restart():
    """Restart ComfyUI server."""
    print("Restarting ComfyUI...")
    comfyui_stop()
    time.sleep(2)
    return comfyui_start()


def project_create(project_name):
    """Create a new project by copying defaults."""
    project_dir = PROJECTS_DIR / project_name
    
    if project_dir.exists():
        print(f"✗ Project '{project_name}' already exists")
        print(f"  Location: {project_dir}")
        return 1
    
    if not DEFAULTS_DIR.exists():
        print(f"✗ Defaults directory not found: {DEFAULTS_DIR}")
        return 1
    
    print(f"Creating project '{project_name}'...")
    
    try:
        # Copy defaults directory
        shutil.copytree(DEFAULTS_DIR, project_dir)
        print(f"  ✓ Copied defaults to {project_dir}")
        
        # Fix paths in AIGen.yaml to point to project-local workflow
        aigen_path = project_dir / "config" / "AIGen.yaml"
        if aigen_path.exists():
            with open(aigen_path, 'r') as f:
                aigen_data = yaml.safe_load(f)
            
            # Update workflow_file path to point to project-local workflow
            # Path should be relative to project root (projects/{name}/)
            # Application will resolve it from the project directory
            # Change from "defaults/workflow/img2img_no_mask_api.json"
            # To "workflow/img2img_no_mask_api.json" (relative to project root)
            if 'workflow_file' in aigen_data:
                # Extract just the filename from the defaults path
                old_path = aigen_data['workflow_file']
                workflow_filename = os.path.basename(old_path)
                # Path relative to project root
                aigen_data['workflow_file'] = f"workflow/{workflow_filename}"
                
                with open(aigen_path, 'w') as f:
                    yaml.dump(aigen_data, f, default_flow_style=False, sort_keys=False)
                print(f"  ✓ Updated workflow_file path in AIGen.yaml to project-local")
            
            # Update project name in rules.yaml if it has one
            rules_path = project_dir / "config" / "rules.yaml"
            if rules_path.exists():
                with open(rules_path, 'r') as f:
                    rules_data = yaml.safe_load(f)
                
                if 'project' in rules_data and 'name' in rules_data['project']:
                    rules_data['project']['name'] = project_name
                    
                    with open(rules_path, 'w') as f:
                        yaml.dump(rules_data, f, default_flow_style=False, sort_keys=False)
                    print(f"  ✓ Updated project name in rules.yaml")
        
        # Create empty directories if they don't exist
        for subdir in ['logs', 'output']:
            subdir_path = project_dir / subdir
            if not subdir_path.exists():
                subdir_path.mkdir(parents=True, exist_ok=True)
        
        print(f"✓ Project '{project_name}' created successfully")
        print(f"  Location: {project_dir}")
        print(f"\nNext steps:")
        print(f"  1. Edit: {project_dir}/config/rules.yaml")
        print(f"  2. Place input image: {project_dir}/input/input.png")
        print(f"  3. Run: iterativectl comfyui start")
        
        return 0
        
    except Exception as e:
        print(f"✗ Error creating project: {e}")
        if project_dir.exists():
            print(f"  Cleaning up...")
            shutil.rmtree(project_dir)
        return 1


def rules_run(args):
    """Run rules_check.py with friendly iterativectl subcommands."""
    rules_check_path = SCRIPT_DIR / "src" / "rules_checker.py"
    if not rules_check_path.exists():
        # Fall back to the legacy wrapper if present
        legacy = SCRIPT_DIR / "rules_check.py"
        if legacy.exists():
            rules_check_path = legacy
        else:
            print(f"✗ rules checker not found: {rules_check_path}")
            return 1

    # Prefer the ComfyUI venv python if available, so dependencies (Pillow, requests, etc.) are present.
    venv_python = COMFYUI_DIR / "venv" / "bin" / "python"
    python_cmd = str(venv_python) if venv_python.exists() else sys.executable

    cmd = [python_cmd, str(rules_check_path)]

    if args.project:
        cmd += ["--project", args.project]
    if args.rules:
        cmd += ["--rules", args.rules]

    if args.action == "check":
        # Lint only
        pass
    elif args.action == "suggest":
        cmd += ["--suggest"]
        if args.apply:
            cmd += ["--apply"]
        if args.overwrite_tags:
            cmd += ["--overwrite-tags"]
        if args.provider:
            cmd += ["--provider", args.provider]
        if args.model:
            cmd += ["--model", args.model]
        if getattr(args, "api_key", None):
            cmd += ["--api-key", args.api_key]
        if getattr(args, "no_colour", False):
            cmd += ["--no-colour"]
        if getattr(args, "no_general_notes", False):
            cmd += ["--no-general-notes"]
        if getattr(args, "guidelines", None):
            cmd += ["--guidelines", args.guidelines]
        if getattr(args, "no_guidelines", False):
            cmd += ["--no-guidelines"]
        if getattr(args, "human_feedback_run", None):
            cmd += ["--human-feedback-run", str(args.human_feedback_run)]
        if getattr(args, "human_feedback_top_k", None) is not None:
            cmd += ["--human-feedback-top-k", str(args.human_feedback_top_k)]
        if args.json:
            cmd += ["--json"]
    else:
        print("✗ Unknown rules action")
        return 1

    try:
        return subprocess.call(cmd, cwd=str(SCRIPT_DIR))
    except Exception as e:
        print(f"✗ Error running rules checker: {e}")
        return 1


def run_imagination(args):
    """Run iterative_imagination.py using the ComfyUI venv python if available."""
    script_path = SCRIPT_DIR / "iterative_imagination.py"
    if not script_path.exists():
        print(f"✗ iterative_imagination.py not found: {script_path}")
        return 1

    # Prefer the ComfyUI venv python if available, so dependencies are present
    venv_python = COMFYUI_DIR / "venv" / "bin" / "python"
    python_cmd = str(venv_python) if venv_python.exists() else sys.executable

    cmd = [python_cmd, str(script_path)]

    if args.project:
        cmd += ["--project", args.project]
    if args.rules:
        cmd += ["--rules", args.rules]
    if args.input:
        cmd += ["--input", args.input]

    if args.reset:
        cmd += ["--reset"]
    if args.resume_from is not None:
        cmd += ["--resume-from", str(args.resume_from)]
    if getattr(args, "seed_from_ranking", None):
        cmd += ["--seed-from-ranking", str(args.seed_from_ranking)]
    if getattr(args, "seed_ranking_mode", None):
        cmd += ["--seed-ranking-mode", str(args.seed_ranking_mode)]
    # Backwards compatible alias
    if getattr(args, "seed_from_human", None):
        cmd += ["--seed-from-human", str(args.seed_from_human)]
    if args.dry_run:
        cmd += ["--dry-run"]
    if args.verbose:
        cmd += ["--verbose"]

    try:
        return subprocess.call(cmd, cwd=str(SCRIPT_DIR))
    except Exception as e:
        print(f"✗ Error running iterative_imagination.py: {e}")
        return 1


def run_masks(args):
    """Run a project with all masks sequentially (useful for multi-mask projects)."""
    proj_dir = SCRIPT_DIR / "projects" / args.project
    if not proj_dir.exists():
        print(f"✗ Project not found: {proj_dir}")
        return 1

    config_aigen_path = proj_dir / "config" / "AIGen.yaml"
    config_rules_path = proj_dir / "config" / "rules.yaml"
    working_dir = proj_dir / "working"
    working_dir.mkdir(parents=True, exist_ok=True)
    working_aigen_path = working_dir / "AIGen.yaml"
    checkpoint_path = working_dir / "checkpoint.json"

    # Load base config
    if config_aigen_path.exists():
        with open(config_aigen_path, "r", encoding="utf-8") as f:
            base_aigen = yaml.safe_load(f) or {}
    else:
        with open(SCRIPT_DIR / "defaults" / "config" / "AIGen.yaml", "r", encoding="utf-8") as f:
            base_aigen = yaml.safe_load(f) or {}

    # Detect masks from rules.yaml
    mask_names = []
    if args.masks:
        mask_names = [m.strip() for m in args.masks.split(",") if m.strip()]
    else:
        # Auto-detect from rules.yaml
        if config_rules_path.exists():
            with open(config_rules_path, "r", encoding="utf-8") as f:
                rules = yaml.safe_load(f) or {}
            masking = rules.get("masking", {})
            masks = masking.get("masks", [])
            if isinstance(masks, list):
                for m in masks:
                    if isinstance(m, dict):
                        name = str(m.get("name", "")).strip()
                        if name and name != "default":  # Skip default mask
                            mask_names.append(name)
            elif isinstance(masks, dict):
                for name in masks.keys():
                    if str(name).strip() != "default":
                        mask_names.append(str(name).strip())

    if not mask_names:
        print("⚠ No masks found in rules.yaml. Use --masks to specify manually.")
        return 1

    print(f"✓ Found {len(mask_names)} mask(s): {', '.join(mask_names)}")

    # Prefer the ComfyUI venv python if available
    venv_python = COMFYUI_DIR / "venv" / "bin" / "python"
    python_cmd = str(venv_python) if venv_python.exists() else sys.executable
    script_path = SCRIPT_DIR / "iterative_imagination.py"

    results = []

    for mask_name in mask_names:
        print(f"\n{'='*60}")
        print(f"Running mask: {mask_name}")
        print(f"{'='*60}")

        # Reset checkpoint between masks
        try:
            if checkpoint_path.exists():
                checkpoint_path.unlink()
        except Exception as e:
            print(f"⚠ Failed to remove checkpoint.json: {e}")

        # Set active_mask in working/AIGen.yaml
        aigen = json.loads(json.dumps(base_aigen))
        aigen.setdefault("masking", {})
        aigen["masking"]["enabled"] = True
        aigen["masking"]["active_mask"] = mask_name

        with open(working_aigen_path, "w", encoding="utf-8") as f:
            yaml.dump(aigen, f, default_flow_style=False, sort_keys=False)

        if args.dry_run:
            print(f"  [DRY RUN] Would run with mask: {mask_name}")
            results.append({"mask": mask_name, "status": "dry_run"})
            continue

        # Run iterative_imagination.py
        cmd = [python_cmd, str(script_path), "--project", args.project]
        if args.verbose:
            cmd.append("--verbose")

        try:
            result = subprocess.run(cmd, cwd=SCRIPT_DIR, check=False)
            status = "success" if result.returncode == 0 else "failed"
            results.append({"mask": mask_name, "status": status, "exit_code": result.returncode})
            
            if result.returncode != 0:
                print(f"✗ Mask '{mask_name}' failed (exit code: {result.returncode})")
                if args.stop_on_error:
                    print("Stopping due to --stop-on-error")
                    break
            else:
                print(f"✓ Mask '{mask_name}' completed")
        except Exception as e:
            print(f"✗ Error running mask '{mask_name}': {e}")
            results.append({"mask": mask_name, "status": "error", "error": str(e)})
            if args.stop_on_error:
                break

    # Summary
    print(f"\n{'='*60}")
    print("Summary:")
    print(f"{'='*60}")
    for r in results:
        status_icon = "✓" if r["status"] == "success" else "✗"
        print(f"  {status_icon} {r['mask']}: {r['status']}")
    
    success_count = sum(1 for r in results if r["status"] == "success")
    print(f"\nCompleted: {success_count}/{len(results)} masks")
    
    return 0 if success_count == len(results) else 1


def run_variants(args):
    """Run a project multiple times with different workflow variants (useful for A/B testing)."""
    proj_dir = SCRIPT_DIR / "projects" / args.project
    if not proj_dir.exists():
        print(f"✗ Project not found: {proj_dir}")
        return 1

    config_aigen_path = proj_dir / "config" / "AIGen.yaml"
    working_dir = proj_dir / "working"
    working_dir.mkdir(parents=True, exist_ok=True)
    working_aigen_path = working_dir / "AIGen.yaml"
    checkpoint_path = working_dir / "checkpoint.json"

    # Require canonical input path. We no longer use input/example.png.
    input_dir = proj_dir / "input"
    input_png = input_dir / "input.png"

    # Load base config from project config if available, else defaults.
    if config_aigen_path.exists():
        with open(config_aigen_path, "r", encoding="utf-8") as f:
            base_aigen = yaml.safe_load(f) or {}
    else:
        with open(SCRIPT_DIR / "defaults" / "config" / "AIGen.yaml", "r", encoding="utf-8") as f:
            base_aigen = yaml.safe_load(f) or {}

    # Derive variant list.
    default_variants = ["baseline", "canny", "openpose", "depth"]
    variants = [v.strip().lower() for v in (args.variants.split(",") if args.variants else default_variants) if v.strip()]
    if not variants:
        variants = default_variants

    mask_enabled = bool(args.mask)
    control_required = {"openpose", "depth"}
    control_path = proj_dir / "input" / "control.png"

    # Pick workflows based on mask setting.
    wf_map_no_mask = {
        "baseline": str(base_aigen.get("workflow_file") or "defaults/workflow/img2img_no_mask_api.json"),
        "canny": "defaults/workflow/img2img_controlnet_canny_api.json",
        "openpose": "defaults/workflow/img2img_controlnet_openpose_api.json",
        "depth": "defaults/workflow/img2img_controlnet_depth_api.json",
    }
    wf_map_inpaint = {
        "baseline": "defaults/workflow/img2img_inpaint_api.json",
        "canny": "defaults/workflow/img2img_inpaint_controlnet_canny_api.json",
        "openpose": "defaults/workflow/img2img_inpaint_controlnet_openpose_api.json",
        "depth": "defaults/workflow/img2img_inpaint_controlnet_depth_api.json",
    }
    wf_map = wf_map_inpaint if mask_enabled else wf_map_no_mask

    # Prefer the ComfyUI venv python if available, so dependencies are present.
    venv_python = COMFYUI_DIR / "venv" / "bin" / "python"
    python_cmd = str(venv_python) if venv_python.exists() else sys.executable
    script_path = SCRIPT_DIR / "iterative_imagination.py"

    results = []

    for v in variants:
        if v not in wf_map:
            print(f"⚠ Unknown variant '{v}', skipping. Known: {', '.join(wf_map.keys())}")
            continue

        if (v in control_required) and (not control_path.exists()) and (not args.force):
            print(f"⚠ Skipping variant '{v}' (requires {control_path}). Use --force to run anyway.")
            continue

        # Reset state between variants by removing checkpoint and writing a fresh working/AIGen.yaml.
        try:
            if checkpoint_path.exists():
                checkpoint_path.unlink()
        except Exception as e:
            print(f"⚠ Failed to remove checkpoint.json: {e}")

        aigen = json.loads(json.dumps(base_aigen))
        aigen["workflow_file"] = wf_map[v]
        aigen.setdefault("masking", {})
        aigen["masking"]["enabled"] = mask_enabled

        with open(working_aigen_path, "w", encoding="utf-8") as f:
            yaml.dump(aigen, f, default_flow_style=False, sort_keys=False)

        print(f"\n=== Running variant: {v} ===")
        print(f"- workflow_file: {aigen['workflow_file']}")
        print(f"- masking.enabled: {mask_enabled}")

        cmd = [python_cmd, str(script_path), "--project", args.project]
        if args.verbose:
            cmd.append("--verbose")
        if args.dry_run:
            cmd.append("--dry-run")

        rc = subprocess.call(cmd, cwd=str(SCRIPT_DIR))

        # After the run, capture run_id and copy output artefacts under the run directory for comparison.
        run_id = None
        try:
            if checkpoint_path.exists():
                with open(checkpoint_path, "r", encoding="utf-8") as f:
                    chk = json.load(f) or {}
                run_id = chk.get("run_id")
        except Exception:
            run_id = None

        if run_id:
            run_root = working_dir / str(run_id)
            exports_dir = run_root / "exports"
            try:
                exports_dir.mkdir(parents=True, exist_ok=True)
                out_png = proj_dir / "output" / "output.png"
                out_meta = proj_dir / "output" / "output_metadata.json"
                if out_png.exists():
                    shutil.copy2(out_png, exports_dir / f"{v}_output.png")
                if out_meta.exists():
                    shutil.copy2(out_meta, exports_dir / f"{v}_output_metadata.json")

                with open(run_root / "variant.json", "w", encoding="utf-8") as f:
                    json.dump(
                        {
                            "variant": v,
                            "workflow_file": aigen["workflow_file"],
                            "masking_enabled": mask_enabled,
                            "exit_code": rc,
                        },
                        f,
                        indent=2,
                    )
            except Exception as e:
                print(f"⚠ Failed to save variant artefacts for run_id={run_id}: {e}")

        results.append({"variant": v, "exit_code": rc, "run_id": run_id})

        # Stop early if requested.
        if rc != 0 and args.stop_on_error:
            print("✗ Stopping due to non-zero exit code (--stop-on-error).")
            break

    print("\n=== Variant run summary ===")
    for r in results:
        print(f"- {r['variant']}: exit={r['exit_code']} run_id={r.get('run_id')}")

    # Return non-zero if any variant failed.
    return 0 if all(r["exit_code"] == 0 for r in results) else 1


def _read_pid_file(pid_path: Path) -> int:
    try:
        if pid_path.exists():
            txt = pid_path.read_text(encoding="utf-8").strip()
            return int(txt)
    except Exception:
        return 0
    return 0


def _pid_is_running(pid: int) -> bool:
    try:
        if pid <= 0:
            return False
        os.kill(pid, 0)
        return True
    except Exception:
        return False


def _find_listening_pids(port: int) -> list[int]:
    """Best-effort: find PIDs listening on a TCP port (Linux/WSL)."""
    pids: set[int] = set()

    # Prefer lsof (most reliable)
    try:
        out = subprocess.check_output(
            ["lsof", "-nP", f"-iTCP:{port}", "-sTCP:LISTEN", "-t"],
            stderr=subprocess.DEVNULL,
            text=True,
        )
        for line in (out or "").splitlines():
            line = line.strip()
            if line.isdigit():
                pids.add(int(line))
        if pids:
            return sorted(pids)
    except Exception:
        pass

    # Fallback: ss
    try:
        out = subprocess.check_output(
            ["ss", "-lptn", f"sport = :{port}"],
            stderr=subprocess.DEVNULL,
            text=True,
        )
        # Example: users:(("python",pid=45530,fd=6))
        for part in (out or "").split("pid=")[1:]:
            pid_str = ""
            for ch in part:
                if ch.isdigit():
                    pid_str += ch
                else:
                    break
            if pid_str:
                pids.add(int(pid_str))
        return sorted(pids)
    except Exception:
        pass

    return []


def viewer_status(host: str = "localhost", port: int = 5000) -> int:
    """Check and display viewer status."""
    viewer_dir = SCRIPT_DIR / "viewer"
    pid_file = viewer_dir / ".viewer.pid"
    pid = _read_pid_file(pid_file)
    is_running = check_port_open(host=host, port=port)
    if is_running:
        extra = f", PID: {pid}" if _pid_is_running(pid) else ""
        print(f"✓ Viewer is running on http://{host}:{port}{extra}")
        return 0
    if _pid_is_running(pid):
        print(f"⚠ Viewer process found (PID: {pid}) but port {port} is not responding")
        return 1
    print("✗ Viewer is not running")
    return 1


def viewer_start(host: str = "127.0.0.1", port: int = 5000) -> int:
    """Start the viewer web app."""
    viewer_dir = SCRIPT_DIR / "viewer"
    app_py = viewer_dir / "app.py"
    if not app_py.exists():
        print(f"✗ Viewer app not found: {app_py}")
        return 1

    if check_port_open(host=host, port=port) or check_port_open(host="localhost", port=port):
        print(f"✓ Viewer is already running on http://{host}:{port}")
        return 0

    # Prefer the ComfyUI venv python if available, so Flask/PyYAML are present.
    venv_python = COMFYUI_DIR / "venv" / "bin" / "python"
    python_cmd = str(venv_python) if venv_python.exists() else sys.executable

    log_file = viewer_dir / "viewer.log"
    pid_file = viewer_dir / ".viewer.pid"

    print("Starting viewer...")
    try:
        with open(log_file, "w") as log:
            process = subprocess.Popen(
                [python_cmd, "app.py"],
                cwd=str(viewer_dir),
                stdout=log,
                stderr=subprocess.STDOUT,
                start_new_session=True,
            )
        pid_file.write_text(str(process.pid), encoding="utf-8")

        # Wait briefly for port to open
        print("  Waiting for viewer to initialise...")
        max_wait = 10
        waited = 0
        while waited < max_wait:
            time.sleep(1)
            waited += 1
            if check_port_open(host="localhost", port=port) or check_port_open(host=host, port=port):
                print(f"✓ Viewer started successfully (PID: {process.pid})")
                print(f"  Access at: http://localhost:{port}")
                print(f"  Logs: {log_file}")
                return 0

        print("⚠ Viewer started but port is not responding yet")
        print(f"  Logs: {log_file}")
        return 1
    except Exception as e:
        print(f"✗ Error starting viewer: {e}")
        return 1


def viewer_restart(host: str = "127.0.0.1", port: int = 5000) -> int:
    """Restart the viewer web app."""
    print("Restarting viewer...")
    viewer_stop(port=port)
    time.sleep(2)
    return viewer_start(host=host, port=port)


def viewer_stop(port: int = 5000) -> int:
    """Stop the viewer web app."""
    viewer_dir = SCRIPT_DIR / "viewer"
    pid_file = viewer_dir / ".viewer.pid"
    pid = _read_pid_file(pid_file)

    if not pid or not _pid_is_running(pid):
        if check_port_open(host="localhost", port=port):
            # PID file missing or stale; try to discover the listener PID(s).
            pids = _find_listening_pids(port)
            if not pids:
                print("⚠ Viewer port is open but PID file/process not found")
                print("  You may need to stop it manually")
                return 1

            print(f"Stopping viewer (found listener PID(s): {', '.join(str(x) for x in pids)})...")
            for p in pids:
                try:
                    os.kill(p, signal.SIGTERM)
                except Exception:
                    pass

            # Wait for port to close
            for _ in range(20):
                time.sleep(0.25)
                if not check_port_open(host="localhost", port=port):
                    try:
                        pid_file.unlink(missing_ok=True)
                    except Exception:
                        pass
                    print("✓ Viewer stopped successfully")
                    return 0

            print("⚠ Force killing viewer...")
            for p in pids:
                try:
                    os.kill(p, signal.SIGKILL)
                except Exception:
                    pass
            time.sleep(0.5)
            try:
                pid_file.unlink(missing_ok=True)
            except Exception:
                pass
            if not check_port_open(host="localhost", port=port):
                print("✓ Viewer stopped")
                return 0
            print("✗ Failed to stop viewer")
            return 1
        print("✓ Viewer is not running")
        return 0

    print(f"Stopping viewer (PID: {pid})...")
    try:
        os.kill(pid, signal.SIGTERM)
        for _ in range(10):
            time.sleep(0.5)
            if not _pid_is_running(pid):
                try:
                    pid_file.unlink(missing_ok=True)
                except Exception:
                    pass
                print("✓ Viewer stopped successfully")
                return 0

        print("⚠ Force killing viewer...")
        os.kill(pid, signal.SIGKILL)
        time.sleep(0.5)
        try:
            pid_file.unlink(missing_ok=True)
        except Exception:
            pass
        if not check_port_open(host="localhost", port=port):
            print("✓ Viewer stopped")
            return 0
        print("✗ Failed to stop viewer")
        return 1
    except ProcessLookupError:
        try:
            pid_file.unlink(missing_ok=True)
        except Exception:
            pass
        print("✓ Viewer process not found (already stopped)")
        return 0
    except Exception as e:
        print(f"✗ Error stopping viewer: {e}")
        return 1


def _http_get_json(url: str, headers: dict | None = None, timeout: int = 5):
    req = urllib.request.Request(url, headers=headers or {}, method="GET")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, json.loads(body) if body else None


def _doctor_check(name: str, ok: bool, detail: str = "") -> None:
    if ok:
        print(f"✓ {name}" + (f" - {detail}" if detail else ""))
    else:
        print(f"✗ {name}" + (f" - {detail}" if detail else ""))


def doctor(project: str | None = None) -> int:
    """Run environment and (optionally) project health checks."""
    exit_code = 0
    print("Iterative Imagination doctor")
    print()

    # Python environment
    venv_python = COMFYUI_DIR / "venv" / "bin" / "python"
    python_cmd = str(venv_python) if venv_python.exists() else sys.executable
    _doctor_check("ComfyUI venv python", venv_python.exists(), str(venv_python) if venv_python.exists() else "not found")

    # Dependency sanity (only checks importability)
    try:
        subprocess.check_output(
            [python_cmd, "-c", "import yaml, requests, websocket; from PIL import Image; print('ok')"],
            stderr=subprocess.STDOUT,
            text=True,
            timeout=10,
        )
        _doctor_check("Python deps (PyYAML/requests/websocket-client/Pillow)", True)
    except Exception as e:
        _doctor_check("Python deps (PyYAML/requests/websocket-client/Pillow)", False, "missing or not in selected python env")
        exit_code = 1

    print()

    # ComfyUI install + service
    _doctor_check("ComfyUI directory", (COMFYUI_DIR / "main.py").exists(), str(COMFYUI_DIR))
    comfyui_ok = check_comfyui_running()
    _doctor_check("ComfyUI running (localhost:8188)", comfyui_ok, "http://localhost:8188" if comfyui_ok else "start with: iterativectl comfyui start")
    if not comfyui_ok:
        exit_code = 1

    # Viewer service
    viewer_ok = check_port_open(host="localhost", port=5000)
    _doctor_check("Viewer running (localhost:5000)", viewer_ok, "http://localhost:5000" if viewer_ok else "start with: iterativectl viewer start")

    print()

    # Ollama service
    ollama_port = check_port_open(host="localhost", port=11434)
    _doctor_check("Ollama port (localhost:11434)", ollama_port)
    if ollama_port:
        try:
            status, tags = _http_get_json("http://localhost:11434/api/tags", timeout=5)
            models = [m.get("name") for m in (tags or {}).get("models", []) if isinstance(m, dict)]
            _doctor_check("Ollama /api/tags", status == 200, f"models: {', '.join(models[:6])}" if models else "ok")
        except Exception as e:
            _doctor_check("Ollama /api/tags", False, "unreachable or invalid response")
            exit_code = 1
    else:
        exit_code = 1

    # OpenRouter key presence (we only check env var here; project config may also embed api_key)
    openrouter_key = os.environ.get("OPENROUTER_API_KEY")
    _doctor_check("OPENROUTER_API_KEY set", bool(openrouter_key), "set in env or ~/.bashrc")

    print()

    if project:
        proj_dir = PROJECTS_DIR / project
        _doctor_check(f"Project exists ({project})", proj_dir.exists(), str(proj_dir))
        if not proj_dir.exists():
            return 1

        rules_path = proj_dir / "config" / "rules.yaml"
        aigen_path = proj_dir / "config" / "AIGen.yaml"
        aivis_path = proj_dir / "config" / "AIVis.yaml"
        input_path = proj_dir / "input" / "input.png"

        _doctor_check("rules.yaml", rules_path.exists(), str(rules_path))
        _doctor_check("AIGen.yaml", aigen_path.exists(), str(aigen_path))
        _doctor_check("AIVis.yaml", aivis_path.exists(), str(aivis_path))
        _doctor_check("input.png", input_path.exists(), str(input_path))

        # Validate workflow_file path
        try:
            if aigen_path.exists():
                with open(aigen_path, "r", encoding="utf-8") as f:
                    aigen = yaml.safe_load(f) or {}
                wf = aigen.get("workflow_file")
                if wf:
                    if str(wf).startswith("/"):
                        wf_path = Path(wf)
                        ok = wf_path.exists()
                        _doctor_check("workflow_file exists", ok, str(wf_path))
                    else:
                        # Try project-relative then repo-root-relative
                        wf_path_proj = (proj_dir / wf).resolve()
                        wf_path_repo = (SCRIPT_DIR / wf).resolve()
                        ok = wf_path_proj.exists() or wf_path_repo.exists()
                        detail = str(wf_path_proj if wf_path_proj.exists() else wf_path_repo)
                        _doctor_check("workflow_file exists", ok, detail)
                else:
                    _doctor_check("workflow_file set", False, "missing workflow_file in AIGen.yaml")
                    exit_code = 1
        except Exception:
            _doctor_check("AIGen.yaml parse", False, "invalid YAML")
            exit_code = 1

        # Validate AIVis provider/model selection
        try:
            if aivis_path.exists():
                with open(aivis_path, "r", encoding="utf-8") as f:
                    aivis = yaml.safe_load(f) or {}
                provider = (aivis.get("provider") or "ollama").lower()
                model = aivis.get("model")
                _doctor_check("AIVis provider", provider in ("ollama", "openrouter"), provider)
                _doctor_check("AIVis model set", bool(model), str(model) if model else "missing model")
                if provider == "openrouter" and not (aivis.get("api_key") or openrouter_key):
                    _doctor_check("OpenRouter API key (project/env)", False, "provider=openrouter but no key available")
                    exit_code = 1
        except Exception:
            _doctor_check("AIVis.yaml parse", False, "invalid YAML")
            exit_code = 1

    return exit_code


def main():
    parser = argparse.ArgumentParser(
        description="Management tool for Iterative Imagination projects",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  iterativectl comfyui start          # Start ComfyUI server
  iterativectl comfyui status         # Check ComfyUI status
  iterativectl viewer start           # Start the viewer web app (http://localhost:5000)
  iterativectl viewer restart         # Restart the viewer web app
  iterativectl viewer status          # Check viewer status
  iterativectl doctor                 # Check environment health (ComfyUI/Ollama/etc.)
  iterativectl doctor --project myproj  # Also check project config and input image
  iterativectl project create myproj  # Create new project 'myproj'
  iterativectl run --project myproj --reset      # Start a fresh run (archives old artefacts)
  iterativectl run --project myproj              # Continue from checkpoint if present, else start at 1
  iterativectl run --project myproj --resume-from 3  # Resume explicitly from iteration 3
  iterativectl run --project myproj --seed-from-ranking latest --seed-ranking-mode rank1  # Seed from #1 human-ranked image
  iterativectl run --project myproj --seed-from-ranking latest --seed-ranking-mode top3   # Average top 3 params, use rank1 prompts
  iterativectl rules check --project myproj
  iterativectl rules suggest --project myproj --apply
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # ComfyUI commands
    comfyui_parser = subparsers.add_parser('comfyui', help='Manage ComfyUI server')
    comfyui_subparsers = comfyui_parser.add_subparsers(dest='action', help='Action')
    
    comfyui_subparsers.add_parser('start', help='Start ComfyUI server')
    comfyui_subparsers.add_parser('stop', help='Stop ComfyUI server')
    comfyui_subparsers.add_parser('restart', help='Restart ComfyUI server')
    comfyui_subparsers.add_parser('status', help='Check ComfyUI status')

    # Viewer commands
    viewer_parser = subparsers.add_parser('viewer', help='Manage the viewer web app')
    viewer_subparsers = viewer_parser.add_subparsers(dest='action', help='Action')
    viewer_subparsers.add_parser('start', help='Start viewer web app (http://localhost:5000)')
    viewer_subparsers.add_parser('stop', help='Stop viewer web app')
    viewer_subparsers.add_parser('restart', help='Restart viewer web app')
    viewer_subparsers.add_parser('status', help='Check viewer status')
    
    # Project commands
    project_parser = subparsers.add_parser('project', help='Manage projects')
    project_subparsers = project_parser.add_subparsers(dest='action', help='Action')
    
    create_parser = project_subparsers.add_parser('create', help='Create a new project')
    create_parser.add_argument('name', help='Project name')

    # Doctor command
    doctor_parser = subparsers.add_parser('doctor', help='Environment and project health checks')
    doctor_parser.add_argument('--project', help='Optional project name to validate configs and input')

    # Run command (iterative_imagination.py)
    run_parser = subparsers.add_parser('run', help='Run iterative_imagination.py for a project (start/reset/resume)')
    run_parser.add_argument('--project', type=str, required=True, help='Project name (uses projects/<name>/config/rules.yaml)')
    run_parser.add_argument('--rules', type=str, help='Path to rules.yaml (alternative to --project)')
    run_parser.add_argument('--input', type=str, help='Path to input image (alternative to project input/input.png)')
    run_parser.add_argument('--reset', action='store_true', help='Reset run state (clears checkpoint and archives old run artefacts)')
    run_parser.add_argument('--resume-from', dest='resume_from', type=int, help='Resume from a specific iteration number')
    run_parser.add_argument('--seed-from-ranking', dest='seed_from_ranking', type=str, help='Seed from a prior run human ranking (RUN_ID or \"latest\")')
    run_parser.add_argument('--seed-ranking-mode', dest='seed_ranking_mode', type=str, default='rank1', help='Seeding mode: rank1|top3|top5 (default: rank1)')
    run_parser.add_argument('--seed-from-human', dest='seed_from_human', type=str, help='(deprecated) alias for --seed-from-ranking')
    run_parser.add_argument('--dry-run', dest='dry_run', action='store_true', help='Validate configs but do not run')
    run_parser.add_argument('--verbose', action='store_true', help='Enable debug logging')

    # Variants command (iterative_imagination.py multiple times with different workflows)
    variants_parser = subparsers.add_parser('variants', help='Run workflow variants back-to-back for a project (A/B testing)')
    variants_parser.add_argument('--project', type=str, required=True, help='Project name (projects/<name>)')
    variants_parser.add_argument('--variants', type=str, default="baseline,canny,openpose,depth", help='Comma-separated: baseline,canny,openpose,depth')
    variants_parser.add_argument('--mask', action='store_true', help='Enable masking (requires input/mask.png for inpaint workflows)')
    variants_parser.add_argument('--force', action='store_true', help='Run even if control.png is missing for pose/depth variants')
    variants_parser.add_argument('--stop-on-error', dest='stop_on_error', action='store_true', help='Stop on first variant failure')
    variants_parser.add_argument('--dry-run', dest='dry_run', action='store_true', help='Validate configs but do not run')
    variants_parser.add_argument('--verbose', action='store_true', help='Enable debug logging')

    # Masks command (run all masks sequentially)
    masks_parser = subparsers.add_parser('masks', help='Run a project with all masks sequentially (left → middle → right)')
    masks_parser.add_argument('--project', type=str, required=True, help='Project name (projects/<name>)')
    masks_parser.add_argument('--masks', type=str, help='Comma-separated mask names (default: auto-detect from rules.yaml)')
    masks_parser.add_argument('--stop-on-error', dest='stop_on_error', action='store_true', help='Stop on first mask failure')
    masks_parser.add_argument('--dry-run', dest='dry_run', action='store_true', help='Validate configs but do not run')
    masks_parser.add_argument('--verbose', action='store_true', help='Enable debug logging')

    # Rules commands
    rules_parser = subparsers.add_parser('rules', help='Lint and AI-suggest tags for rules.yaml')
    rules_subparsers = rules_parser.add_subparsers(dest='action', help='Action')

    rules_check_parser = rules_subparsers.add_parser('check', help='Lint rules.yaml (schema and tag shape)')
    rules_check_parser.add_argument('--project', help='Project name (projects/<name>/config/rules.yaml)')
    rules_check_parser.add_argument('--rules', help='Path to rules.yaml (overrides --project)')

    rules_suggest_parser = rules_subparsers.add_parser('suggest', help='Use AIVis to suggest better acceptance_criteria tags')
    rules_suggest_parser.add_argument('--project', help='Project name (projects/<name>/config/rules.yaml)')
    rules_suggest_parser.add_argument('--rules', help='Path to rules.yaml (overrides --project)')
    rules_suggest_parser.add_argument('--apply', action='store_true', help='Apply suggestions back into rules.yaml')
    rules_suggest_parser.add_argument('--overwrite-tags', dest='overwrite_tags', action='store_true', help='Overwrite existing tags instead of filling/merging')
    rules_suggest_parser.add_argument('--provider', help='Override AIVis provider (ollama/openrouter)')
    rules_suggest_parser.add_argument('--model', help='Override AIVis model')
    rules_suggest_parser.add_argument('--api-key', dest='api_key', help='OpenRouter API key override (otherwise uses OPENROUTER_API_KEY)')
    rules_suggest_parser.add_argument('--no-colour', dest='no_colour', action='store_true', help='Disable ANSI colours in output')
    rules_suggest_parser.add_argument('--no-general-notes', dest='no_general_notes', action='store_true', help='Do not print AI general_notes (useful for restricted projects)')
    rules_suggest_parser.add_argument('--guidelines', help='Path to guidelines markdown file to send to AIVis')
    rules_suggest_parser.add_argument('--no-guidelines', dest='no_guidelines', action='store_true', help='Send no guidelines to AIVis')
    rules_suggest_parser.add_argument('--human-feedback-run', dest='human_feedback_run', help="Include human ranking notes from working/<run_id>/human/ranking.json (RUN_ID or 'latest')")
    rules_suggest_parser.add_argument('--human-feedback-top-k', dest='human_feedback_top_k', type=int, default=3, help='When including human feedback, include notes from top K ranked iterations (default: 3)')
    rules_suggest_parser.add_argument('--json', action='store_true', help='Emit raw suggestions JSON')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    if args.command == 'comfyui':
        if args.action == 'start':
            return comfyui_start()
        elif args.action == 'stop':
            return comfyui_stop()
        elif args.action == 'restart':
            return comfyui_restart()
        elif args.action == 'status':
            return comfyui_status()
        else:
            comfyui_parser.print_help()
            return 1
    
    elif args.command == 'project':
        if args.action == 'create':
            return project_create(args.name)
        else:
            project_parser.print_help()
            return 1

    elif args.command == 'viewer':
        if args.action == 'start':
            return viewer_start()
        elif args.action == 'stop':
            return viewer_stop()
        elif args.action == 'restart':
            return viewer_restart()
        elif args.action == 'status':
            return viewer_status()
        else:
            viewer_parser.print_help()
            return 1

    elif args.command == 'doctor':
        return doctor(project=getattr(args, "project", None))

    elif args.command == 'run':
        return run_imagination(args)
    
    elif args.command == 'variants':
        return run_variants(args)
    
    elif args.command == 'masks':
        return run_masks(args)

    elif args.command == 'rules':
        if not args.action:
            rules_parser.print_help()
            return 1
        return rules_run(args)
    
    else:
        parser.print_help()
        return 1


if __name__ == '__main__':
    sys.exit(main())
